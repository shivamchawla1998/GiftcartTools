import {
  latestVersion
} from "./chunk-7YJH7P7B.js";
import {
  require_semver
} from "./chunk-FAFQQMD4.js";
import {
  AbortController,
  AbortError,
  BugError,
  exec,
  fileExists,
  findPathUp,
  glob,
  outputContent,
  outputDebug,
  outputToken,
  readFile,
  runWithTimer,
  writeFile
} from "./chunk-4IXC46ZA.js";
import {
  dirname,
  joinPath
} from "./chunk-MHMFNQE3.js";
import {
  __export,
  __toESM,
  init_cjs_shims
} from "./chunk-M63RTPGR.js";

// ../cli-kit/src/public/node/node-package-manager.ts
var node_package_manager_exports = {};
__export(node_package_manager_exports, {
  FindUpAndReadPackageJsonNotFoundError: () => FindUpAndReadPackageJsonNotFoundError,
  PackageJsonNotFoundError: () => PackageJsonNotFoundError,
  UnknownPackageManagerError: () => UnknownPackageManagerError,
  addNPMDependencies: () => addNPMDependencies,
  addNPMDependenciesIfNeeded: () => addNPMDependenciesIfNeeded,
  addNPMDependenciesWithoutVersionIfNeeded: () => addNPMDependenciesWithoutVersionIfNeeded,
  addResolutionOrOverride: () => addResolutionOrOverride,
  bunLockfile: () => bunLockfile,
  checkForNewVersion: () => checkForNewVersion,
  findUpAndReadPackageJson: () => findUpAndReadPackageJson,
  getDependencies: () => getDependencies,
  getPackageManager: () => getPackageManager,
  getPackageName: () => getPackageName,
  getPackageVersion: () => getPackageVersion,
  installNPMDependenciesRecursively: () => installNPMDependenciesRecursively,
  installNodeModules: () => installNodeModules,
  lockfiles: () => lockfiles,
  npmLockfile: () => npmLockfile,
  packageManager: () => packageManager,
  packageManagerFromUserAgent: () => packageManagerFromUserAgent,
  pnpmLockfile: () => pnpmLockfile,
  pnpmWorkspaceFile: () => pnpmWorkspaceFile,
  readAndParsePackageJson: () => readAndParsePackageJson,
  usesWorkspaces: () => usesWorkspaces,
  writePackageJSON: () => writePackageJSON,
  yarnLockfile: () => yarnLockfile
});
init_cjs_shims();
var import_semver = __toESM(require_semver(), 1);
var yarnLockfile = "yarn.lock";
var npmLockfile = "package-lock.json";
var pnpmLockfile = "pnpm-lock.yaml";
var bunLockfile = "bun.lockb";
var pnpmWorkspaceFile = "pnpm-workspace.yaml";
var lockfiles = [yarnLockfile, pnpmLockfile, npmLockfile, bunLockfile];
var packageManager = ["yarn", "npm", "pnpm", "bun", "unknown"];
var UnknownPackageManagerError = class extends AbortError {
  constructor() {
    super("Unknown package manager");
  }
};
var PackageJsonNotFoundError = class extends AbortError {
  constructor(directory) {
    super(outputContent`The directory ${outputToken.path(directory)} doesn't have a package.json.`);
  }
};
var FindUpAndReadPackageJsonNotFoundError = class extends BugError {
  constructor(directory) {
    super(outputContent`Couldn't find a a package.json traversing directories from ${outputToken.path(directory)}`);
  }
};
function packageManagerFromUserAgent(env = process.env) {
  if (env.npm_config_user_agent?.includes("yarn")) {
    return "yarn";
  } else if (env.npm_config_user_agent?.includes("pnpm")) {
    return "pnpm";
  } else if (env.npm_config_user_agent?.includes("bun")) {
    return "bun";
  } else if (env.npm_config_user_agent?.includes("npm")) {
    return "npm";
  }
  return "unknown";
}
async function getPackageManager(fromDirectory) {
  const packageJson = await findPathUp("package.json", { cwd: fromDirectory, type: "file" });
  if (!packageJson) {
    return packageManagerFromUserAgent();
  }
  const directory = dirname(packageJson);
  outputDebug(outputContent`Obtaining the dependency manager in directory ${outputToken.path(directory)}...`);
  const yarnLockPath = joinPath(directory, yarnLockfile);
  const pnpmLockPath = joinPath(directory, pnpmLockfile);
  const bunLockPath = joinPath(directory, bunLockfile);
  if (await fileExists(yarnLockPath)) {
    return "yarn";
  } else if (await fileExists(pnpmLockPath)) {
    return "pnpm";
  } else if (await fileExists(bunLockPath)) {
    return "bun";
  } else {
    return "npm";
  }
}
async function installNPMDependenciesRecursively(options) {
  const packageJsons = await glob(joinPath(options.directory, "**/package.json"), {
    ignore: [joinPath(options.directory, "node_modules/**/package.json")],
    cwd: options.directory,
    onlyFiles: true,
    deep: options.deep
  });
  const abortController = new AbortController();
  try {
    await Promise.all(
      packageJsons.map(async (packageJsonPath) => {
        const directory = dirname(packageJsonPath);
        await installNodeModules({
          directory,
          packageManager: options.packageManager,
          stdout: void 0,
          stderr: void 0,
          signal: abortController.signal,
          args: []
        });
      })
    );
  } catch (error) {
    abortController.abort();
    throw error;
  }
}
async function installNodeModules(options) {
  const execOptions = {
    cwd: options.directory,
    stdin: void 0,
    stdout: options.stdout,
    stderr: options.stderr,
    signal: options.signal
  };
  let args = ["install"];
  if (options.args) {
    args = args.concat(options.args);
  }
  await runWithTimer("cmd_all_timing_network_ms")(async () => {
    await exec(options.packageManager, args, execOptions);
  });
}
async function getPackageName(packageJsonPath) {
  const packageJsonContent = await readAndParsePackageJson(packageJsonPath);
  return packageJsonContent.name;
}
async function getPackageVersion(packageJsonPath) {
  const packageJsonContent = await readAndParsePackageJson(packageJsonPath);
  return packageJsonContent.version;
}
async function getDependencies(packageJsonPath) {
  const packageJsonContent = await readAndParsePackageJson(packageJsonPath);
  const dependencies = packageJsonContent.dependencies ?? {};
  const devDependencies = packageJsonContent.devDependencies ?? {};
  return { ...dependencies, ...devDependencies };
}
async function usesWorkspaces(appDirectory) {
  const packageJsonPath = joinPath(appDirectory, "package.json");
  const packageJsonContent = await readAndParsePackageJson(packageJsonPath);
  const pnpmWorkspacePath = joinPath(appDirectory, pnpmWorkspaceFile);
  return Boolean(packageJsonContent.workspaces) || fileExists(pnpmWorkspacePath);
}
async function checkForNewVersion(dependency, currentVersion) {
  outputDebug(outputContent`Checking if there's a version of ${dependency} newer than ${currentVersion}`);
  try {
    const lastVersion = await getLatestNPMPackageVersion(dependency);
    if (lastVersion && new import_semver.SemVer(currentVersion).compare(lastVersion) < 0) {
      return lastVersion;
    } else {
      return void 0;
    }
  } catch (error) {
    return void 0;
  }
}
async function readAndParsePackageJson(packageJsonPath) {
  if (!await fileExists(packageJsonPath)) {
    throw new PackageJsonNotFoundError(dirname(packageJsonPath));
  }
  return JSON.parse(await readFile(packageJsonPath));
}
async function addNPMDependenciesIfNeeded(dependencies, options) {
  outputDebug(outputContent`Adding the following dependencies if needed:
${outputToken.json(dependencies)}
With options:
${outputToken.json(options)}
  `);
  const packageJsonPath = joinPath(options.directory, "package.json");
  if (!await fileExists(packageJsonPath)) {
    throw new PackageJsonNotFoundError(options.directory);
  }
  const existingDependencies = Object.keys(await getDependencies(packageJsonPath));
  const dependenciesToAdd = dependencies.filter((dep) => {
    return !existingDependencies.includes(dep.name);
  });
  if (dependenciesToAdd.length === 0) {
    return;
  }
  await addNPMDependencies(dependenciesToAdd, options);
}
async function addNPMDependencies(dependencies, options) {
  const dependenciesWithVersion = dependencies.map((dep) => {
    return dep.version ? `${dep.name}@${dep.version}` : dep.name;
  });
  options.stdout?.write(`Installing ${[dependenciesWithVersion].join(" ")} with ${options.packageManager}`);
  switch (options.packageManager) {
    case "npm":
      for (const dep of dependenciesWithVersion) {
        await installDependencies(options, argumentsToAddDependenciesWithNPM(dep, options.type));
      }
      break;
    case "yarn":
      await installDependencies(
        options,
        argumentsToAddDependenciesWithYarn(dependenciesWithVersion, options.type, Boolean(options.addToRootDirectory))
      );
      break;
    case "pnpm":
      await installDependencies(
        options,
        argumentsToAddDependenciesWithPNPM(dependenciesWithVersion, options.type, Boolean(options.addToRootDirectory))
      );
      break;
    case "bun":
      await installDependencies(options, argumentsToAddDependenciesWithBun(dependenciesWithVersion, options.type));
      await installDependencies(options, ["install"]);
      break;
    case "unknown":
      throw new UnknownPackageManagerError();
  }
}
async function installDependencies(options, args) {
  return runWithTimer("cmd_all_timing_network_ms")(async () => {
    return exec(options.packageManager, args, {
      cwd: options.directory,
      stdout: options.stdout,
      stderr: options.stderr,
      signal: options.signal
    });
  });
}
async function addNPMDependenciesWithoutVersionIfNeeded(dependencies, options) {
  await addNPMDependenciesIfNeeded(
    dependencies.map((dependency) => {
      return { name: dependency, version: void 0 };
    }),
    options
  );
}
function argumentsToAddDependenciesWithNPM(dependency, type) {
  let command = ["install"];
  command = command.concat(dependency);
  switch (type) {
    case "dev":
      command.push("--save-dev");
      break;
    case "peer":
      command.push("--save-peer");
      break;
    case "prod":
      command.push("--save-prod");
      break;
  }
  if (dependency.match(/@\d/g)) {
    command.push("--save-exact");
  }
  return command;
}
function argumentsToAddDependenciesWithYarn(dependencies, type, addAtRoot = false) {
  let command = ["add"];
  if (addAtRoot) {
    command.push("-W");
  }
  command = command.concat(dependencies);
  switch (type) {
    case "dev":
      command.push("--dev");
      break;
    case "peer":
      command.push("--peer");
      break;
    case "prod":
      command.push("--prod");
      break;
  }
  return command;
}
function argumentsToAddDependenciesWithPNPM(dependencies, type, addAtRoot = false) {
  let command = ["add"];
  if (addAtRoot) {
    command.push("-w");
  }
  command = command.concat(dependencies);
  switch (type) {
    case "dev":
      command.push("--save-dev");
      break;
    case "peer":
      command.push("--save-peer");
      break;
    case "prod":
      command.push("--save-prod");
      break;
  }
  return command;
}
function argumentsToAddDependenciesWithBun(dependencies, type) {
  let command = ["add"];
  command = command.concat(dependencies);
  switch (type) {
    case "dev":
      command.push("--development");
      break;
    case "peer":
      command.push("--optional");
      break;
    case "prod":
      break;
  }
  return command;
}
async function findUpAndReadPackageJson(fromDirectory) {
  const packageJsonPath = await findPathUp("package.json", { cwd: fromDirectory, type: "file" });
  if (packageJsonPath) {
    const packageJson = JSON.parse(await readFile(packageJsonPath));
    return { path: packageJsonPath, content: packageJson };
  } else {
    throw new FindUpAndReadPackageJsonNotFoundError(fromDirectory);
  }
}
async function addResolutionOrOverride(directory, dependencies) {
  const packageManager2 = await getPackageManager(directory);
  const packageJsonPath = joinPath(directory, "package.json");
  const packageJsonContent = await readAndParsePackageJson(packageJsonPath);
  if (packageManager2 === "yarn") {
    packageJsonContent.resolutions = packageJsonContent.resolutions ? { ...packageJsonContent.resolutions, ...dependencies } : dependencies;
  }
  if (packageManager2 === "npm" || packageManager2 === "pnpm" || packageManager2 === "bun") {
    packageJsonContent.overrides = packageJsonContent.overrides ? { ...packageJsonContent.overrides, ...dependencies } : dependencies;
  }
  await writeFile(packageJsonPath, JSON.stringify(packageJsonContent, null, 2));
}
async function getLatestNPMPackageVersion(name) {
  outputDebug(outputContent`Getting the latest version of NPM package: ${outputToken.raw(name)}`);
  return runWithTimer("cmd_all_timing_network_ms")(() => {
    return latestVersion(name);
  });
}
async function writePackageJSON(directory, packageJSON) {
  outputDebug(outputContent`JSON-encoding and writing content to package.json at ${outputToken.path(directory)}...`);
  const packagePath = joinPath(directory, "package.json");
  await writeFile(packagePath, JSON.stringify(packageJSON, null, 2));
}

export {
  yarnLockfile,
  npmLockfile,
  pnpmLockfile,
  bunLockfile,
  pnpmWorkspaceFile,
  lockfiles,
  packageManager,
  UnknownPackageManagerError,
  PackageJsonNotFoundError,
  FindUpAndReadPackageJsonNotFoundError,
  packageManagerFromUserAgent,
  getPackageManager,
  installNPMDependenciesRecursively,
  installNodeModules,
  getPackageName,
  getPackageVersion,
  getDependencies,
  usesWorkspaces,
  checkForNewVersion,
  readAndParsePackageJson,
  addNPMDependenciesIfNeeded,
  addNPMDependencies,
  addNPMDependenciesWithoutVersionIfNeeded,
  findUpAndReadPackageJson,
  addResolutionOrOverride,
  writePackageJSON,
  node_package_manager_exports
};
