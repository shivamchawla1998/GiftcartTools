import {
  require_notifier
} from "./chunk-CKKROMZF.js";
import {
  fanoutHooks,
  reportAnalyticsEvent
} from "./chunk-63QEL3SZ.js";
import {
  getEnvironmentData
} from "./chunk-B4KDQK3X.js";
import {
  CLI_KIT_VERSION
} from "./chunk-5NBS5LAW.js";
import {
  AbortSilentError,
  CancelExecution,
  cleanSingleStackTracePath,
  errorMapper,
  getAllPublicMetadata,
  getAllSensitiveMetadata,
  handler,
  outputDebug,
  outputInfo,
  printEventsJson,
  shouldReportError
} from "./chunk-4IXC46ZA.js";
import {
  require_stacktracey
} from "./chunk-LUGC3D2G.js";
import {
  bugsnagApiKey
} from "./chunk-PCQFWMMD.js";
import {
  require_lib
} from "./chunk-67MDUPX5.js";
import {
  cwd,
  isAbsolutePath,
  joinPath,
  normalizePath,
  relativePath
} from "./chunk-MHMFNQE3.js";
import {
  __toESM,
  init_cjs_shims
} from "./chunk-M63RTPGR.js";

// ../cli-kit/src/public/node/error-handler.ts
init_cjs_shims();
var import_core = __toESM(require_lib(), 1);
var import_stacktracey = __toESM(require_stacktracey(), 1);
var import_js = __toESM(require_notifier(), 1);
import { realpath } from "fs/promises";
async function errorHandler(error, config) {
  if (error instanceof CancelExecution) {
    if (error.message && error.message !== "") {
      outputInfo(`\u2728  ${error.message}`);
    }
  } else if (error instanceof AbortSilentError) {
    printEventsJson();
  } else {
    return errorMapper(error).then((error2) => {
      return handler(error2);
    }).then((mappedError) => {
      printEventsJson();
      return reportError(mappedError, config);
    });
  }
}
var reportError = async (error, config) => {
  let exitMode = "expected_error";
  if (shouldReportError(error))
    exitMode = "unexpected_error";
  if (config !== void 0) {
    await reportAnalyticsEvent({ config, errorMessage: error instanceof Error ? error.message : void 0, exitMode });
  }
  await sendErrorToBugsnag(error, exitMode);
};
async function sendErrorToBugsnag(error, exitMode) {
  if (import_core.settings.debug) {
    outputDebug(`Skipping Bugsnag report`);
    return { reported: false, error, unhandled: void 0 };
  }
  const unhandled = exitMode === "unexpected_error";
  let reportableError;
  let stacktrace;
  let report = false;
  if (error instanceof Error) {
    report = true;
    reportableError = new Error(error.message);
    stacktrace = error.stack;
  } else if (typeof error === "string" && error.trim().length !== 0) {
    report = true;
    reportableError = new Error(error);
    stacktrace = reportableError.stack;
  } else {
    report = false;
    reportableError = new Error("Unknown error");
  }
  const formattedStacktrace = new import_stacktracey.default(stacktrace ?? "").clean().items.map((item) => {
    const filePath = cleanSingleStackTracePath(item.file);
    return `    at ${item.callee} (${filePath}:${item.line}:${item.column})`;
  }).join("\n");
  reportableError.stack = `Error: ${reportableError.message}
${formattedStacktrace}`;
  if (report) {
    initializeBugsnag();
    await new Promise((resolve, reject) => {
      outputDebug(`Reporting ${unhandled ? "unhandled" : "handled"} error to Bugsnag: ${reportableError.message}`);
      const eventHandler = (event) => {
        event.severity = "error";
        event.unhandled = unhandled;
      };
      const errorHandler2 = (error2) => {
        if (error2) {
          reject(error2);
        } else {
          resolve(reportableError);
        }
      };
      import_js.default.notify(reportableError, eventHandler, errorHandler2);
    });
  }
  return { error: reportableError, reported: report, unhandled };
}
function cleanStackFrameFilePath({
  currentFilePath,
  projectRoot,
  pluginLocations
}) {
  const fullLocation = isAbsolutePath(currentFilePath) ? currentFilePath : joinPath(projectRoot, currentFilePath);
  const matchingPluginPath = pluginLocations.filter(({ pluginPath }) => fullLocation.indexOf(pluginPath) === 0)[0];
  if (matchingPluginPath !== void 0) {
    return joinPath(matchingPluginPath.name, relativePath(matchingPluginPath.pluginPath, fullLocation));
  }
  return currentFilePath.replace(/.*node_modules\//, "");
}
async function registerCleanBugsnagErrorsFromWithinPlugins(config) {
  const bugsnagConfigProjectRoot = import_js.default?._client?._config?.projectRoot ?? cwd();
  const projectRoot = normalizePath(bugsnagConfigProjectRoot);
  const pluginLocations = await Promise.all(
    [...config.plugins].map(async ([_, plugin]) => {
      const followSymlinks = await realpath(plugin.root);
      return { name: plugin.name, pluginPath: normalizePath(followSymlinks) };
    })
  );
  initializeBugsnag();
  import_js.default.addOnError(async (event) => {
    event.errors.forEach((error) => {
      error.stacktrace.forEach((stackFrame) => {
        stackFrame.file = cleanStackFrameFilePath({ currentFilePath: stackFrame.file, projectRoot, pluginLocations });
      });
    });
    try {
      await addBugsnagMetadata(event, config);
    } catch (metadataError) {
      outputDebug(`There was an error adding metadata to the Bugsnag report; Ignoring and carrying on ${metadataError}`);
    }
  });
}
async function addBugsnagMetadata(event, config) {
  const publicData = getAllPublicMetadata();
  const { commandStartOptions } = getAllSensitiveMetadata();
  const { startCommand } = commandStartOptions ?? {};
  const { "@shopify/app": appPublic, ...otherPluginsPublic } = await fanoutHooks(config, "public_command_metadata", {});
  const environment = await getEnvironmentData(config);
  const allMetadata = {
    command: startCommand,
    ...appPublic,
    ...publicData,
    ...environment,
    pluginData: otherPluginsPublic
  };
  const appData = {};
  const commandData = {};
  const environmentData = {};
  const miscData = {};
  const appKeys = ["api_key", "partner_id", "project_type"];
  const commandKeys = ["command"];
  const environmentKeys = ["cli_version", "node_version", "ruby_version", "uname"];
  Object.entries(allMetadata).forEach(([key, value]) => {
    if (key.startsWith("app_") || appKeys.includes(key)) {
      appData[key] = value;
    } else if (key.startsWith("cmd_") || commandKeys.includes(key)) {
      commandData[key] = value;
    } else if (key.startsWith("env_") || environmentKeys) {
      environmentData[key] = value;
    } else {
      miscData[key] = value;
    }
  });
  const bugsnagMetadata = {
    "Shopify App": appData,
    Command: commandData,
    Environment: environmentData,
    Misc: miscData
  };
  Object.entries(bugsnagMetadata).forEach(([section, values]) => {
    event.addMetadata(section, values);
  });
}
function initializeBugsnag() {
  if (import_js.default.isStarted()) {
    return;
  }
  import_js.default.start({
    appType: "node",
    apiKey: bugsnagApiKey,
    logger: null,
    appVersion: CLI_KIT_VERSION,
    autoTrackSessions: false,
    autoDetectErrors: false
  });
}

export {
  errorHandler,
  sendErrorToBugsnag,
  cleanStackFrameFilePath,
  registerCleanBugsnagErrorsFromWithinPlugins,
  addBugsnagMetadata
};
